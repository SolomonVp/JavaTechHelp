### interface - интерфейс.  

Пример листинга интерфейса. (с дженериками)  
(Дженерики 1)[http://cyclowiki.org/wiki/Generic_(Java)]  
[Дженерики 2](http://www.quizful.net/post/java-generics-tutorial)  
(Дженерики 3)(http://developer.alexanderklimov.ru/android/java/generic.php)  

    public interface Store<T, ID> {  
        void add(T t);  
        void update(T t, ID i); 
        void delete(ID i);
        T findOne(ID i);
        List<T> findAll();
    }

Распространенный круд, от CRUD (Create, Read, Update, Delete) интерфейс.

Работа со многими базами данных строится по такому принципу,
создать запись, прочитать, обновить, удалить.  

Обозначается public, потому что должен реализовываться(implements) классом, т.е.
должен описать в себе все методы интерфейса. Еще это называют контрактом.

- - - 

Грубо простейший пример реализации в классе:

    void add (T t) {
        bookstore.add(t);
    }

Вместо T t, будет подставляться некий дженерик, в двух словах это ТИП переменной,
поэтому и обозначается чаще всего как `T = Type`.
В нашем примере допустим может быть такой:

    void add (Book book) {
        bookstore.add(book);
    }

Естественно на место Book book вы можете подставить любую переменную, которая вам
нужна для вашей реализации. Другими словами для простого понимания можно
теоретически представить что `T = Object`, а поскольку в java все является Object,
то можно определить туда так же любой ваш класс/переменную, единственный трабл
будет возникать потом, при 565

Своими словами - некая программная структура, определяющая отношения между  
объектами, посредством разделения их на некие поведенческие части.  
Цель интерфейса - определение функционала для реализации его классом.  

Простыми словами, это описание сигнатур методов. Внутри интерфейса находятся  
названия методов, возвращаюшие и входящие значения, и все. Ну можно еще обозначить
там какие-то переменные, но они сразу становятся неявно public static final,
и могут быть доступны из любой части программы.  

Интерфейс описывает действия, а поэтому в нем находятся, - эти самые действия,
т.е. функции или методы.  


- - -  

Зачем это нужно? Что это упрощает или какие дает преимущества?


Упрощение описания действий, поведения. Мы говорим что делать, а как это делать,
каждый класс реализует сам. Экономия времени в больших проектах. Интерфейсы
создаются в ситуациях, когда мы знаем, что нужно выполнить некоторую задачу, но
как это сделать, может отличаться.

Интерфейс описывает названия действий, это просто как направление некой абстракции.
Хотя могут встречаться и интерфейсы без методов и полей, такие как маркеры,
типа Cloneable, Remote итп.


Возьмем всеми любимый пример с автомобилем. Интерфейс в нем будет описывать
возможные действия машины, поворот руля или направление
движения, набор скорости, остаток бензина итп. Т.е. те самые действия,
которые могут быть у абсолютно любого автомобиля. Другими словами, мы
опускаемся в дебри деградации на самый низший уровень создания самого
первого автомобиля и своими мозгами додумываем, как он создавался и что у
него было. Естественно мы описываем это абстрактно и только для действий.
Что было у самого первого авто?
Руль был? был, значит куда-то поворачивался, направление руля/движения.
Колеса были? Да, значит ехал, и ехал с какой-то скоростью, что-то 
меняло скорость, мотор под капотом, напишем изменение скорости.

Вот и весь интерфейс. Но, в целом интерфейсы создаются под
какую-то реализацию неких действий. Т.е. мы пишем программу для более
конкретных действий, чем для вообще всего, что только можно придумать.
Поэтому и сами интерфейсы будут иметь в себе более четкие и конкретные
методы. Конечно же они будут на столько абстрактны, на сколько это
возможно. Интерфейсы могут быть наследованы друг от друга как классы.

    interface MyInterface extends NotMyinterface;

Интерфейсы реализовываются в классах. Реализовывать можно сколько
угодно интерфейсов. В отличие от наследования, наследоваться только от
одного.

    class NewClass extends OldClass implements MyInterface, NotMyinterface;

Т.е. мы придумали какие-то действия, придумали им названия, входящие данные,
возвращаемые данные, написали все это в интерфейсе, потом создали класс и
добавили наш интерфейс к этом классу, т.е. реализовали наш интерфейс в этом
классе. Далее все описаные в интерфейсе методы/функции, должны обязательно
иметь реализацию. Ее можно сделать как непосредственно в самом интерфейсе,
тогда нужно добавить слово default перед методом и написать реализацию
прямо в методе, подобно классу. Это стало возможным с 8 версии джавы. Так
и в классе, который будет реализовывать этот интерфейс.


Если вам не нужно половина методов, можно создать сначала интерфейс,
унаследовать от нужного интерфейса, определить в нем вашу добрую половину
не нужных методов как дефолтные, допилить пустую реализацию и все, или
сделать такое же прямо в самом  интерфейсе, но лучше не делать, потому что
интерфейс юзают наверно многие, а вы хоп и поменяете им кучу дефолтов. Хотя
в целом, если это ваш интерфейс, откуда там взяться этим лишним и не
нужным методам еще вопрос. 


Ну вот, интерфейс написали, заимплементили в класс, накатили реализацию в
классе, можно запускать и тестить.

Так же можно почитать в интерфейсах про:
- Статические методы.
- Приватные методы. (повтор кода)
- Переменные/Константы.
- Вложенные интерфейсы.
Но это уже лучше попозже, да и лишним голову забивать тоже вредно.

Интересный вопрос, что такое Volvo ? Class or Interface ?

    line1: Volvo v = new VolvoV2();  
    line2: Volvo v = new VolvoV3();  


[Интерфейс](https://metanit.com/java/tutorial/3.7.php)  
[Интерфейс](http://developer.alexanderklimov.ru/android/java/interface.php)  

todo - functional interfaces
todo - top main
todo - shema
















