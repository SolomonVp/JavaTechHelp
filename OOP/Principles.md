### Object Oriented Programming Principles
- - -
#### ООП Принципы.
- - -
ООП - Объекто Ориентированное Программирование.  

Класс — это описание, шаблон, чертеж, будущего объекта, который может иметь  
поля, методы, конструктор. В целом вы просто создаете описание новой  
переменной, а потом создаете ее как обычный примитив.  

Объект – экземпляр класса, созданный из этого описания, ваша новая  
переменная, ссылка на память где она лежит.  

#### `4 принципа.`

    1) Инкапсуляция.
    2) Полиморфизм.
    3) Наследование.
    4) Абстракция.

Теперь поподробнее:  
- - -
 1) Инкапсуляция.  

Дословно - "Все в капсулу". Переменная создается в отдельном классе, все  
методы, поля  и работа с ней происходит внутри класса, тем самым скрывается  
внутренняя реализация. Но для доступа к классу создаются getter & setter.  
Помогает систему любых размеров уложить в голове.  
(Мы знаем что делает класс, а как он это делает нас не волнует.)  

Зачем это нужно?  

- Позволяет не знакомому программисту с этим классом, использовать его.  
- Упрощяет и ускоряет разработку. (при средних и больших масштабах)  
- Ограничить доступ к переменным и связывать их с методами внутри класса.  
reflection это не помеха, и скорее это в понимании  
`как нужно делать`, а не `это безопасно.`  

[Инкапсуляция и reflect HABR](https://habr.com/post/43859/)  
[Инкапсуляция](https://guru99.ru/java-oops-encapsulation/)  
[Очень доступно и понятно SOF](https://ru.stackoverflow.com/questions/794196/%D0%98%D0%BD%D0%BA%D0%B0%D0%BF%D1%81%D1%83%D0%BB%D1%8F%D1%86%D0%B8%D1%8F-%D0%9F%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF%D1%8B-%D0%9E%D0%9E%D0%9F/794204)

[todo] need test view
- - -
 2) Наследование.  

 
Вся сущность копирует ссылки  на предка, если те не изменены/переопределены
в настоящей реализации, помимо чего может и, как правило, добавляет/привносит  
что-то новое, что не присуще предку, тем самым уменьшая абстракцию и  
конкретизируя действия.  

Зачем это нужно?  

- Создание похожего объекта.  
- Уменьшение объема кода.  

[todo $^]

- - -
 3) Полиморфизм.  

Организация множественных реализаций одного класса.  

- Переопределение.  

public class Dog (){  
	public void hi(){  
	System.Out.Println("i am dog");  
	}  
}  

public class Taksa() extends Dog(){  
	@Override  
	public void hi(){  
	System.Out.Println("i am dog, my name taksa");  
	}  
}  


`override должно иметь такую же сигнатуру метода и такой же возвращаемый тип.`  
`override может иметь <= настоящему доступу.`  
`(Может быть private всегда, но не может быть public, если был protected.)`  

- Перегрузка.  

public class Dog (){  
	public void hi(String str){  
	System.Out.Println("i am - " + str);  
	}  
	public void hi(String str, String str){  
	System.Out.Println(str + str2);  
	}  
}  

Зачем это нужно?  

- Упрощение работы с методами.  
- Увеличение возможности применения.  
- Изменение реализации части класса.  

- - -
 4) Абстракция.  


Создание некоего общего интерфейса, свойства которого будут присущи в  
дальнейшем абсолютно всем элементам/классам реализующим его. Например класс  
Object, от него наследуются все классы в Java. Отделение базовых от  
составляющих свойств более высших классов.  

[todo $^]

- - -
[4 принципы](http://www.internet-technologies.ru/articles/chetyre-principa-obektno-orientirovannogo-programmirovaniya-v-java.html)
[Я не знаю ООП](https://habr.com/post/147927/)  
[Шпаргалка по принципам ООП](https://tproger.ru/translations/oop-principles-cheatsheet/)  
[Госы - ООП](http://gos-it.wikia.com/wiki/%D0%AD%D1%82%D0%BE_%D0%B3%D0%BE%D1%81%D1%8B!)  
[Статья на Javarush](https://javarush.ru/groups/posts/1880--principih-oop)  
[Wiki - ООП](https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)


