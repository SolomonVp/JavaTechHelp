### Object Oriented Programming Principles
- - -
#### ООП Принципы.
- - -
ООП - аббревиатура Объектно Ориентированное Программирование.  
Из самого названия ясно, что это Программирование, которое использует  
Ориентацию на Объекты, т.е. в основе ее лежит Объект.  
Так же есть похожее АОП - Аспектно ОП, но об этом позже.  

Класс — это описание, шаблон, чертеж, будущего объекта, который может иметь  
поля, методы, конструктор. В целом вы просто создаете описание новой  
переменной, а потом создаете ее как обычный примитив.  

Объект – экземпляр класса, созданная из этого описания, ваша новая  
переменная, ссылка на память где она лежит.  

#### `4 принципа.`

    1) Инкапсуляция.
    2) Полиморфизм.
    3) Наследование.
    4) Абстракция.

Теперь поподробнее:  
- - -
 1) Инкапсуляция.  

Дословно - "Все в капсулу". Переменная создается в отдельном классе, все  
методы, поля  и работа с ней происходит внутри класса, тем самым скрывается  
внутренняя реализация. Но для доступа к классу создаются getter & setter.  
Помогает систему любых размеров уложить в голове.  
(Мы знаем что делает класс, а как он это делает нас не волнует.)  

Зачем это нужно?  

- Позволяет не знакомому программисту с этим классом, использовать его.  
- Упрощяет и ускоряет разработку. (при средних и больших масштабах)  
- Ограничить доступ к переменным и связывать их с методами внутри класса.  
reflection это не помеха, и скорее это в понимании  
`как нужно делать`, а не `это безопасно.`  

[Инкапсуляция и reflect HABR](https://habr.com/post/43859/)  
[Инкапсуляция](https://guru99.ru/java-oops-encapsulation/)  
[Очень доступно и понятно SOF](https://ru.stackoverflow.com/questions/794196/%D0%98%D0%BD%D0%BA%D0%B0%D0%BF%D1%81%D1%83%D0%BB%D1%8F%D1%86%D0%B8%D1%8F-%D0%9F%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF%D1%8B-%D0%9E%D0%9E%D0%9F/794204)

[todo $^]  
- - -
 2) Наследование.  

Вся сущность копирует ссылки  на предка, если те не изменены/переопределены  
в настоящей реализации, помимо чего может и, как правило, добавляет/привносит  
что-то новое, что не присуще предку, тем самым уменьшая абстракцию и  
конкретизируя действия.  

Основной класс называется `базовым, родительским или суперклассом.`  
Класс который наследует основной называется — `потомком, наследником,  
дочерним или производным классом.`  

Зачем это нужно?  

- Создание похожего объекта.  
- Уменьшение объема кода.  

[todo $^]  

- - -
 3) Полиморфизм.  

Организация множественных реализаций одного  
интерфейса/метода/абстрактного класса.  

Переопределение и Перегрузка. Один и тот же метод, разные и там  
и там реализации, разница лишь в том, что переопределение меняет  
метод с такой же сигнатурой, а перегрузка меняет ее, сигнатуру,  
т.е. принимаемые параметры. Ну и переопределение происходит при  
наследовании, а перегрузка внутри класса.  


- Переопределение.  

public class Dog (){  
	public void hi(){  
	System.Out.Println("i am dog");  
	}  
}  

public class Taksa() extends Dog(){  
	@Override  
	public void hi(){  
	System.Out.Println("i am dog, my name taksa");  
	}  
}  


`override должно иметь такую же сигнатуру метода и такой же возвращаемый тип.`  
`override может иметь <= настоящему доступу.`  
`(Может быть private всегда, но не может быть public, если был protected.)`  

- Перегрузка.  

public class Dog (){  
	public void hi(String str){  
	System.Out.Println("i am - " + str);  
	}  
	public void hi(String str, String str){  
	System.Out.Println(str + str2);  
	}  
}  

Зачем это нужно?  

- Упрощение работы с методами.  
- Увеличение возможности применения.  
- Изменение реализации части класса.  


`Пример с реализацией интерфейса.`  

	public interface Shape {
		void draw();
	}

	public class Circle implements Shape {
		public void draw() {
			System.out.println("Circle");
		}
	}
	public class Triangle implements Shape {
		public void draw() {
			System.out.println("Triangle");
		}
	}
	 
	public class TestPol {
	 
		public static void main(String[] args) {
			Shape shape_1 = new Circle();
			Shape shape_2 = new Triangle();
			testDraw(shape_1);
			testDraw(shape_2);
		}
	 
		public static void testDraw(Shape shape) {
			shape.draw();
		}
	}

Выводе в консоль:  
Circle  
Triangle  

- - -
 4) Абстракция.  

Выберите какой-нибудь фрукт. Выбрали? 90% выбирают яблоко. В плане животного  
это становится корова итд. Но не об этом. Важно другое, что абсолютно все  
представляют себе и фрукт и животное по-разному. Потому что это абстракции.
Если сказать фрукт, представляется группа разных, схожих по каким-то  
параметрам моделей, которые что-то 100% объединяет. Так вот это объединение  
и есть общая абстракция. Эти общие параметры совсем не обязательно являются  
важными. Например удельный вес нагрузки на стул это важный параметр, другими  
словами это его крепкость, но в части абстракции это совсем безразлично.  
Однако все определения в интернете глаголят о важности этих параметров. И  
тут какой-нибудь кретин скажет, так если это безразлично, значит не важный  
параметр! ))) Похлопаем ему, он подтвердил, что именно такой.  

Некий общий интерфейс, свойства которого будут присущи в дальнейшем абсолютно  
всем элементам/классам реализующим его. Например класс Object, от него  
наследуются все классы в Java. Стоит отметить, что абстракция в Java это или  
interface или abstract class. Но в целом, любой класс, даже с реализацией  
может быть сугубо абстрактным, в части того, что его будут расширять  
наследники, поэтому он будет своего рода некой абстракцией от будущих классов.  
НО, в JAVA принято считать абстракцией только то, где есть некое описание и  
нет реализации. Например любой класс, в котором есть хотя бы 1 абстрактный  
метод обязан быть абстрактным. И это понятно, ведь мы не можем сделать объект  
с присущими ему какими-то действиями, которых по факту-то просто нет.  Хотя  
можем, но тогда это действие бесполезно и становится бессмысленным.  

Например стул это общая, центральная абстракция.  
Деревянный стул это тоже абстракция, но более детальная.  
Деревянный стул с мягкой спинкой, тоже абстрация, но еще более детальная. итд.  
До полного и детального описания со всеми возможными характеристиками.  

Например:

    abstract class Chair; // абстракция стул
        setChairLegs();  // ножки
        setChairSeat();  // сиденье
        ...

    abstract class ChairLegs;  // абстракция ножки
        setMaterial();  // материал
        setHeight();  // высота
        setWidth();  // ширина
        setStyle();  // стиль
        ...

    enum Material {  // перечисление материала
        Wood,  // деревянный
        Metal,  // металлический
        Glass  // стеклянный
        ...
    }

    enum Style {  // перечисление стилей
        Round,  // круглый
        Square,  // квадратный
        Triangle  // треугольный
        ...
    }

Этот пример можно переписать через обычные классы, суть программно это не  
поменяет никак и наверно даже будет более правильно, сделано просто для  
понимания абстракции.  

[wiki - Абстракция в общем](https://ru.wikipedia.org/wiki/%D0%90%D0%B1%D1%81%D1%82%D1%80%D0%B0%D0%BA%D1%86%D0%B8%D1%8F)  

[todo $^]

- - -  

#### `Дополнительно 3 принципа.`

    1) Ассоциация.  
    2) Агрегация.  
    3) Композиция.  
	
[Кратко по делу](http://sergeyteplyakov.blogspot.com/2012/12/vs-vs.html)  
- - -  
	1) Ассоциация.  

Просто некая связь между объектами. Имеет 2 частных случая: Агрегация и Композиция.  
Это как абстрактный класс, реализующий 2 обычных класса.  
Это своего рода отношение между объектами.  

- - -  
	2) Агрегация.  

Отношение при котором один объект является частью второго.  
Они могу существовать отдельно, изменяться, удаляться, создаваться.  

- - -  
	3) Композиция.  

Аналог Агрегации, с одним замечанием.  
Первый объект управляет жизненным циклом второго, что это значит?  
При создании Первого, создается и второй.  
При удалении Первого, удаляется и второй.  
Полная инкапсуляция второго внутрь первого.  

- - -  

[4 принципы](http://www.internet-technologies.ru/articles/chetyre-principa-obektno-orientirovannogo-programmirovaniya-v-java.html)
[Я не знаю ООП](https://habr.com/post/147927/)  
[Шпаргалка по принципам ООП](https://tproger.ru/translations/oop-principles-cheatsheet/)  
[Госы - ООП](http://gos-it.wikia.com/wiki/%D0%AD%D1%82%D0%BE_%D0%B3%D0%BE%D1%81%D1%8B!)  
[Статья на Javarush](https://javarush.ru/groups/posts/1880--principih-oop)  
[Wiki - ООП](https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)


